{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useAppDispatch, useAppSelector } from '../../hooks';\nimport { setDeletingBoard, setDeletingTask, setSubmissionTrigger, setTaskEditing, setExistingTask } from '../../../../main/slices';\nexport let ModalTypes;\n(function (ModalTypes) {\n  ModalTypes[\"TaskManager\"] = \"taskManager\";\n  ModalTypes[\"TaskEditor\"] = \"taskEditor\";\n  ModalTypes[\"Remover\"] = \"remover\";\n  ModalTypes[\"Temp\"] = \"temp\";\n})(ModalTypes || (ModalTypes = {}));\nexport const useAppModal = () => {\n  _s();\n  const {\n    taskManaging,\n    taskEditing,\n    boardManaging,\n    deletingBoard,\n    deletingTask\n  } = useAppSelector(state => state.modals);\n  const open = taskManaging || taskEditing || boardManaging || deletingBoard || deletingTask;\n  const dispatch = useAppDispatch();\n  const type = deletingBoard ? ModalTypes.Remover : taskManaging ? ModalTypes.TaskManager : taskEditing ? ModalTypes.TaskEditor : ModalTypes.Temp;\n  function closeRemover() {\n    dispatch(setDeletingBoard(false));\n    dispatch(setDeletingTask(false));\n  }\n  function closeTaskManager() {\n    dispatch(setSubmissionTrigger(true));\n  }\n  function closeTaskEditor() {\n    dispatch(setTaskEditing(false));\n    dispatch(setExistingTask(false));\n  }\n  const getOnClose = type => ({\n    [ModalTypes.Remover]: closeRemover,\n    [ModalTypes.TaskManager]: closeTaskManager,\n    [ModalTypes.TaskEditor]: closeTaskEditor,\n    [ModalTypes.Temp]: closeRemover\n\n    // [MODAL_TYPES.optional]: OptionalModal,\n  })[type];\n  return {\n    type,\n    open,\n    getOnClose\n  };\n};\n\n// export const useAppModal = () => {\n//    const [isModalOpen, setIsModalOpen] = useState(false);\n\n//    const handleOpen = () => {\n//       setIsModalOpen(true);\n//    };\n\n//    const handleClose = () => {\n//       setIsModalOpen(false);\n//    };\n\n//    return {\n//       isModalOpen,\n//       handleOpen,\n//       handleClose\n//    }\n// }\n_s(useAppModal, \"gzfrs6ohFj3tpgk/JGS0mgtrdn4=\", false, function () {\n  return [useAppSelector, useAppDispatch];\n});","map":{"version":3,"names":["useAppDispatch","useAppSelector","setDeletingBoard","setDeletingTask","setSubmissionTrigger","setTaskEditing","setExistingTask","ModalTypes","useAppModal","taskManaging","taskEditing","boardManaging","deletingBoard","deletingTask","state","modals","open","dispatch","type","Remover","TaskManager","TaskEditor","Temp","closeRemover","closeTaskManager","closeTaskEditor","getOnClose"],"sources":["/home/danny/projects/r-fm-kanban-management/src/library/common/components/AppModal/useAppModal.ts"],"sourcesContent":["import { useAppDispatch, useAppSelector } from '../../hooks';\nimport {\n   setDeletingBoard,\n   setDeletingTask,\n   setSubmissionTrigger,\n   setTaskEditing,\n   setExistingTask,\n} from '../../../../main/slices';\n\nexport enum ModalTypes {\n   TaskManager = 'taskManager',\n   TaskEditor = 'taskEditor',\n   Remover = 'remover',\n   Temp = 'temp',\n}\n\nexport const useAppModal = () => {\n   const {\n      taskManaging,\n      taskEditing,\n      boardManaging,\n      deletingBoard,\n      deletingTask,\n   } = useAppSelector((state) => state.modals);\n   const open =\n      taskManaging ||\n      taskEditing ||\n      boardManaging ||\n      deletingBoard ||\n      deletingTask;\n\n   const dispatch = useAppDispatch();\n\n   const type = deletingBoard\n      ? ModalTypes.Remover\n      : taskManaging\n      ? ModalTypes.TaskManager\n      : taskEditing\n      ? ModalTypes.TaskEditor\n      : ModalTypes.Temp;\n\n   function closeRemover() {\n      dispatch(setDeletingBoard(false));\n      dispatch(setDeletingTask(false));\n   }\n\n   function closeTaskManager() {\n      dispatch(setSubmissionTrigger(true));\n   }\n\n   function closeTaskEditor() {\n      dispatch(setTaskEditing(false));\n      dispatch(setExistingTask(false));\n   }\n\n   const getOnClose = (type: ModalTypes) =>\n      ({\n         [ModalTypes.Remover]: closeRemover,\n         [ModalTypes.TaskManager]: closeTaskManager,\n         [ModalTypes.TaskEditor]: closeTaskEditor,\n         [ModalTypes.Temp]: closeRemover,\n\n         // [MODAL_TYPES.optional]: OptionalModal,\n      }[type]);\n\n   return { type, open, getOnClose };\n};\n\n// export const useAppModal = () => {\n//    const [isModalOpen, setIsModalOpen] = useState(false);\n\n//    const handleOpen = () => {\n//       setIsModalOpen(true);\n//    };\n\n//    const handleClose = () => {\n//       setIsModalOpen(false);\n//    };\n\n//    return {\n//       isModalOpen,\n//       handleOpen,\n//       handleClose\n//    }\n// }\n"],"mappings":";AAAA,SAASA,cAAc,EAAEC,cAAc,QAAQ,aAAa;AAC5D,SACGC,gBAAgB,EAChBC,eAAe,EACfC,oBAAoB,EACpBC,cAAc,EACdC,eAAe,QACX,yBAAyB;AAEhC,WAAYC,UAAU;AAKrB,WALWA,UAAU;EAAVA,UAAU;EAAVA,UAAU;EAAVA,UAAU;EAAVA,UAAU;AAAA,GAAVA,UAAU,KAAVA,UAAU;AAOtB,OAAO,MAAMC,WAAW,GAAG,MAAM;EAAA;EAC9B,MAAM;IACHC,YAAY;IACZC,WAAW;IACXC,aAAa;IACbC,aAAa;IACbC;EACH,CAAC,GAAGZ,cAAc,CAAEa,KAAK,IAAKA,KAAK,CAACC,MAAM,CAAC;EAC3C,MAAMC,IAAI,GACPP,YAAY,IACZC,WAAW,IACXC,aAAa,IACbC,aAAa,IACbC,YAAY;EAEf,MAAMI,QAAQ,GAAGjB,cAAc,EAAE;EAEjC,MAAMkB,IAAI,GAAGN,aAAa,GACrBL,UAAU,CAACY,OAAO,GAClBV,YAAY,GACZF,UAAU,CAACa,WAAW,GACtBV,WAAW,GACXH,UAAU,CAACc,UAAU,GACrBd,UAAU,CAACe,IAAI;EAEpB,SAASC,YAAY,GAAG;IACrBN,QAAQ,CAACf,gBAAgB,CAAC,KAAK,CAAC,CAAC;IACjCe,QAAQ,CAACd,eAAe,CAAC,KAAK,CAAC,CAAC;EACnC;EAEA,SAASqB,gBAAgB,GAAG;IACzBP,QAAQ,CAACb,oBAAoB,CAAC,IAAI,CAAC,CAAC;EACvC;EAEA,SAASqB,eAAe,GAAG;IACxBR,QAAQ,CAACZ,cAAc,CAAC,KAAK,CAAC,CAAC;IAC/BY,QAAQ,CAACX,eAAe,CAAC,KAAK,CAAC,CAAC;EACnC;EAEA,MAAMoB,UAAU,GAAIR,IAAgB,IAChC;IACE,CAACX,UAAU,CAACY,OAAO,GAAGI,YAAY;IAClC,CAAChB,UAAU,CAACa,WAAW,GAAGI,gBAAgB;IAC1C,CAACjB,UAAU,CAACc,UAAU,GAAGI,eAAe;IACxC,CAAClB,UAAU,CAACe,IAAI,GAAGC;;IAEnB;EACH,CAAC,EAACL,IAAI,CAAE;EAEX,OAAO;IAAEA,IAAI;IAAEF,IAAI;IAAEU;EAAW,CAAC;AACpC,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA,GApEalB,WAAW;EAAA,QAOjBP,cAAc,EAQDD,cAAc;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}